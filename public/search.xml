<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>第 三 篇文章 Git</title>
      <link href="/2022/08/10/22-08-10-3/"/>
      <url>/2022/08/10/22-08-10-3/</url>
      
        <content type="html"><![CDATA[<h1 id="Git"><a href="#Git" class="headerlink" title="Git"></a>Git</h1><p><strong>上传到github</strong>先git init, git add . ,git commit -m ‘ ‘, 再关联远程库</p><p>Git 中的三个<strong>区域</strong>：工作区、暂存区、Git 仓库。</p><p>工作区：处理工作的区域</p><p>暂存区：已完成的工作的临时存放区域，等待被提交</p><p>Git 仓库：最终的存放区域</p><p>Git 中的三种<strong>状态</strong>：已修改 modified 已暂存 staged 已提交 committed</p><p><strong>已修改</strong>：表示修改了文件，但还没将修改的结果放到暂存区。</p><p><strong>已暂存</strong>：表示对已修改文件的当前 版本做了标记，使之包含 在下次提交的列表中。</p><p><strong>已提交</strong>：表示文件已经安全地保存 在本地的 Git 仓库中。</p><p>注意：</p><p>⚫ 工作区的文件被修改了，但还没有放到暂存区，就是已修改状态。</p><p>⚫ 如果文件已修改并放入暂存区，就属于已暂存状态。</p><p>⚫ 如果 Git 仓库中保存着特定版本的文件，就属于已提交状态。</p><h2 id="Git的基本操作"><a href="#Git的基本操作" class="headerlink" title="Git的基本操作"></a>Git的基本操作</h2><ol><li><p>git init 命令会创建一个名为 .git 的隐藏目录，这个 .git 目录就是当前项目的 Git 仓库，里面包含了初始的必要文件，这些文件是 Git 仓库的必要组成部分。</p></li><li><p>git add 开始跟踪一个文件，git add . 一次性将所有的新增和修改过的文件加入暂存区</p></li><li><p>git status 命令查看文件处于什么状态</p></li><li><p>git commit 命令进行提交, 其中 -m 选项后面是本次的提交消息，用来对提交的内容做进一步的描述：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git commit -m <span class="string">&#x27;什么信息&#x27;</span></span><br></pre></td></tr></table></figure></li><li><p>跳过使用暂存区域</p></li></ol><p>Git 标准的工作流程是<strong>工作区 → 暂存区 → Git 仓库</strong>。Git 工作的流程简化为了<strong>工作区 → Git 仓库</strong>。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git commit -a -m <span class="string">&#x27;描述信息&#x27;</span></span><br></pre></td></tr></table></figure><ol start="6"><li><p>移除文件</p><p>从 Git 仓库中移除文件的方式有两种： </p><p>① 从 Git 仓库和工作区中同时移除对应的文件 </p><p>② 只从 Git 仓库中移除指定的文件，但保留工作区中对应的文件</p></li></ol><p><img src="/img/image-20221025163441508.png"></p><h2 id="Git分支的概念"><a href="#Git分支的概念" class="headerlink" title="Git分支的概念"></a>Git分支的概念</h2><p>master 主分支</p><p>功能分支</p><ol><li><p>创建新分支       <strong>git branch 分支名称</strong>  </p><p>基于当前分支，创建一个新的分支，创建好分支后，当前位置还是在master分支上</p></li><li><p>切换分支     <strong>git checkout 分支名称</strong>     </p><p>可以切换到指定的分支上进行开发</p></li><li><p>分支的快速创建和切换  <strong>git checkout -b 分支名称</strong></p></li><li><p>合并分支   先切换到 master分支上，再运行 <strong>git merge 分支名称</strong> 命令，来合并功能分支</p><p>功能分支的代码开发测试完毕之后，可以使用命令，将完成后的代码合并到 master 主分支上</p></li><li><p>删除分支 <strong>git branch -d 分支名称</strong></p><p>当把功能分支的代码合并到 master 主分支上以后，就可以使用命令，删除对应的功能分支</p></li></ol><p>​6、git remote prune origin 清理本地仓库中与远程仓库中origin关联的已经不存在的分支引用</p><h2 id="远程分支操作"><a href="#远程分支操作" class="headerlink" title="远程分支操作"></a>远程分支操作</h2><ol><li>将本地分支推送到远程仓库</li></ol><p>​如果是第一次将本地分支推送到远程仓库，需要运行如下的命令：<br><img src="/img/image-20221025164401144.png"></p><p>gitlab的操作，git pull origin 分支名</p><ol start="2"><li><p>查看远程仓库中所有的分支列表</p><p>通过如下的命令，可以查看远程仓库中，所有的分支列表的信息：</p></li></ol><p><img src="/img/image-20221025164457908.png"></p><ol start="3"><li>跟踪分支</li></ol><p>​跟踪分支指的是：从远程仓库中，把远程分支下载到本地仓库中。需要运行的命令如下：<br><img src="/img/image-20221025164539512.png"></p><ol start="4"><li><p>拉取远程分支的最新的代码</p><p>首先切换到本地分支</p><p>git pull origin 远程分支名</p><p>可以使用如下的命令，把远程分支最新的代码下载到本地对应的分支中：</p></li></ol><p><img src="/img/image-20221025164618940.png"></p><ol start="5"><li><p>删除远程分支</p><p>可以使用如下的命令，删除远程仓库中指定的分支：</p></li></ol><p><img src="/img/image-20221025164652215.png"></p><ol start="6"><li>合并分支冲突</li></ol><p>如果在两个不同的分支中，对同一个文件进行了不同的修改，Git 就没法干净的合并它们。 此时，我们需要打开 这些包含冲突的文件然后手动解决冲突。、</p><h2 id="git-clone"><a href="#git-clone" class="headerlink" title="git clone"></a>git clone</h2><p>git init</p><p>然后git clone +url</p><p>如果连接不上就</p><p><a href="https://blog.csdn.net/greatcoder/article/details/126138230">https://blog.csdn.net/greatcoder/article/details/126138230</a></p><p>git clone <a href="https://ghproxy.com/+github%E7%BD%91%E7%AB%99%E5%9C%B0%E5%9D%80">https://ghproxy.com/+github网站地址</a></p><p>就比如 git clone <a href="https://ghproxy.com/https://github.com/HaogegeShy/jingdong.git">https://ghproxy.com/https://github.com/HaogegeShy/jingdong.git</a></p><h2 id="git问题error-remote-origin-already-exists"><a href="#git问题error-remote-origin-already-exists" class="headerlink" title="git问题error: remote origin already exists"></a>git问题error: remote origin already exists</h2><p><a href="https://blog.csdn.net/qq_39208536/article/details/125231265">https://blog.csdn.net/qq_39208536/article/details/125231265</a></p><p>如果你clone下来一个别人的仓库，在此基础上完成你的代码，推送到自己的仓库可能遇到如下问题：<br>error: remote origin already exists.表示远程仓库已存在。<br>因此你要进行以下操作：<br>1、先输入git remote rm origin 删除关联的origin的远程库<br>2、关联自己的仓库 git remote add origin <a href="https://gitee.com/xxxxxx.git">https://gitee.com/xxxxxx.git</a><br>3、最后git push origin master，这样就推送到自己的仓库了。</p><h2 id="git代码提交到远程仓库时"><a href="#git代码提交到远程仓库时" class="headerlink" title="git代码提交到远程仓库时"></a>git代码提交到远程仓库时</h2><p>选用ssh的方式</p><h2 id="git-rebase和git-merge的区别"><a href="#git-rebase和git-merge的区别" class="headerlink" title="git rebase和git merge的区别"></a>git rebase和git merge的区别</h2><p>1、rebase变基，把当前的commit放到公共分支的最后面，merge把当前的commit和公共分支合并在一起，会产生一个合并的commit；</p><p>2、用merge命令解决完冲突后会产生一个commit，而用rebase命令解决完冲突后不会产生额外的commit。</p><p>merge中fast-forward 不会产生commit提交，–no-ff 会产生commit提交</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>第 二 篇文章 VUE底层原理</title>
      <link href="/2022/08/05/22-08-05-2/"/>
      <url>/2022/08/05/22-08-05-2/</url>
      
        <content type="html"><![CDATA[<h1 id="vue原理"><a href="#vue原理" class="headerlink" title="vue原理"></a>vue原理</h1><h2 id="1、mvvm"><a href="#1、mvvm" class="headerlink" title="1、mvvm"></a>1、mvvm</h2><ul><li>M：模型Model  —&gt;也就是data中的数据</li><li>V：视图View  —&gt;也就是dom</li><li>VM：视图模型ViewModel  —&gt;也就是Vue实例（vm）</li></ul><p><img src="/img/image-20230521163900590.png"></p><h2 id="2、vue响应式原理"><a href="#2、vue响应式原理" class="headerlink" title="2、vue响应式原理"></a>2、vue响应式原理</h2><h3 id="核心api-object-defineProperty"><a href="#核心api-object-defineProperty" class="headerlink" title="核心api object.defineProperty"></a>核心api object.defineProperty</h3><p><img src="/img/image-20230521164959631.png"></p><p>vue响应式也叫作数据双向绑定，大致原理阐述：</p><p> 首先我们需要通过Object.defineProperty()方法把数据(data)设置为getter和setter的访问形式，这样我们就可以在数据被修改时在setter方法设置监视修改页面信息，也就是说每当数据被修改，就会触发对应的set方法，然后我们可以在set方法中去调用操作dom的方法。</p><p> 此外，如果页面有input用v-model绑定数据，我们需要在这种绑定了data的input元素上添加监听，添加input事件监听，每当input事件被触发时，就修改对应的data</p><p>原文链接：<a href="https://blog.csdn.net/weixin_48181168/article/details/120158346">https://blog.csdn.net/weixin_48181168/article/details/120158346</a></p><p><img src="/img/image-20230521192401756.png"></p><h3 id="vue3启用proxy"><a href="#vue3启用proxy" class="headerlink" title="vue3启用proxy"></a><strong>vue3启用proxy</strong></h3><p><a href="https://blog.csdn.net/pagnzong/article/details/120389514">https://blog.csdn.net/pagnzong/article/details/120389514</a></p><p>代码</p><p><img src="/img/image-20230522155235201.png"></p><h3 id="proxy和object-defineProperty响应式的对比"><a href="#proxy和object-defineProperty响应式的对比" class="headerlink" title="proxy和object.defineProperty响应式的对比"></a>proxy和object.defineProperty响应式的对比</h3><p>vue2响应式的缺点：</p><ul><li>检测不到对象属性的添加和删除 （需要使用vue.set, vue.delete）</li><li>数组<code>API</code>方法无法监听到 (需要特殊处理)</li><li>深度监听需要递归到底，造成性能问题</li></ul><p>proxy解决的问题</p><ul><li>克服了vue2响应式的问题</li><li>缺点：没有兼容ie等其他浏览器，无法实现polyfill</li></ul><h2 id="3、虚拟dom和diff算法和react-diff的区别"><a href="#3、虚拟dom和diff算法和react-diff的区别" class="headerlink" title="3、虚拟dom和diff算法和react diff的区别"></a>3、虚拟dom和diff算法和react diff的区别</h2><p>用JS模拟DOM结构（vnode）<br>增量更新： 新旧vnode对比，得出最小的更新范围，最后更新DOM</p><p>数据驱动视图的模式下，有效控制DOM操作</p><p><img src="/img/image-20230521193406678.png"></p><p>diff算法</p><ul><li><p>当数据发生改变时，订阅者<code>watcher</code>就会调用<code>patch</code>给真实的<code>DOM</code>打补丁</p></li><li><p>通过<code>isSameVnode</code>进行判断，相同则调用<code>patchVnode</code>方法</p></li><li><pre><code>patchVnode<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">  做了以下操作：</span><br><span class="line"></span><br><span class="line">  - 找到对应的真实`dom`，称为`el`</span><br><span class="line">  - 如果都有都有文本节点且不相等，将`el`文本节点设置为`Vnode`的文本节点</span><br><span class="line">  - 如果`oldVnode`有子节点而`VNode`没有，则删除`el`子节点</span><br><span class="line">  - 如果`oldVnode`没有子节点而`VNode`有，则将`VNode`的子节点真实化后添加到`el`</span><br><span class="line">  - 如果两者都有子节点，则执行`updateChildren`函数比较子节点</span><br><span class="line"></span><br><span class="line">- ```</span><br><span class="line">  updateChildren</span><br></pre></td></tr></table></figure>主要做了以下操作：- 设置新旧`VNode`的头尾指针- 新旧头尾指针进行比较，循环向中间靠拢，根据情况调用`patchVnode`进行`patch`重复流程、调用`createElem`创建一个新节点，从哈希表寻找 `key`一致的`VNode` 节点再分情况操作</code></pre></li></ul><p><strong>相同点：</strong><br>Vue和react的diff算法，都是不进行跨层级比较，只做同级比较</p><p><strong>不同点：</strong></p><ol><li>vue会在patch函数中给被操作的节点打补丁（patchflag），在diff的时候更清晰</li><li>vue对比节点，当节点元素类型相同，但是className不同时，认为是不同类型的元素，删除重新创建；而react则认为是同类型节点，进行修改操作</li><li>diff策略，vue的性能优于react</li></ol><h2 id="4、模板编译template"><a href="#4、模板编译template" class="headerlink" title="4、模板编译template"></a>4、模板编译template</h2><p>template-&gt;render-&gt;h-&gt;vdom-&gt;true dom</p><h2 id="5、vue组件的渲染和更新流程"><a href="#5、vue组件的渲染和更新流程" class="headerlink" title="5、vue组件的渲染和更新流程"></a>5、vue组件的渲染和更新流程</h2><p>初次渲染<br><img src="/img/image-20230521212323764.png"></p><p>更新<br><img src="/img/image-20230521212411230.png"></p><p>完整流程图<br><img src="/img/image-20230521212545143.png"></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>第 一 篇文章 React底层原理</title>
      <link href="/2022/07/30/22-07-30-1/"/>
      <url>/2022/07/30/22-07-30-1/</url>
      
        <content type="html"><![CDATA[<h1 id="React-底层原理"><a href="#React-底层原理" class="headerlink" title="React 底层原理"></a>React 底层原理</h1><p>至此我们介绍了react的理念，如何解决cpu和io的瓶颈，关键是实现异步可中断的更新</p><p>我们介绍了react源码架构（ui&#x3D;fn(state)），从scheduler开始调度（根据过期事件判断优先级，时间分片），经过render阶段的深度优先遍历形成effectList（中间会执行reconcile|diff），交给commit处理真实节点（中间穿插生命周期和部分hooks），而这些调度的过程都离不开Fiber的支撑，<strong>Fiber是工作单元，也是节点优先级、更新UpdateQueue、节点信息的载体</strong>，Fiber双缓存则提供了对比前后节点更新的基础。我们还介绍了jsx是React.createElement的语法糖。Lane模型则提供了更细粒度的优先级对比和计算，这一切都为concurrent mode提供了基础，在这之上变可以实现Suspense和batchedUpdate（16、17版本实现的逻辑不一样），context的valueStack和valueCursor在整个架构中运行机制，最后介绍了新版事件系统，包括事件生产、监听和触发</p><h2 id="1-react的架构"><a href="#1-react的架构" class="headerlink" title="1. react的架构"></a>1. react的架构</h2><p><a href="https://juejin.cn/post/7211072055780573221#heading-0">https://juejin.cn/post/7211072055780573221#heading-0</a></p><p><a href="https://juejin.cn/post/6926432527980691470">https://juejin.cn/post/6926432527980691470</a></p><p>作为架构来说，之前<code>React15</code>的<code>Reconciler</code>采用递归的方式执行，数据保存在递归调用栈中，所以被称为<code>stack Reconciler</code>。<code>React16</code>的<code>Reconciler</code>基于<code>Fiber节点</code>实现，被称为<code>Fiber Reconciler</code>。</p><p>新版React架构分为三大部分：</p><ul><li>Scheduler调度器：  排序优先级，让优先级高的任务先进行reconcile</li><li>Reconciler协调器：接受更新，创建虚拟dom树，找出哪些节点发生了改变，并打上不同的effectTag</li><li>Renderer渲染器：将Reconciler中打好标签的节点渲染到视图上</li></ul><p>Fiber这种数据结构后，能完成哪些事情呢，</p><ul><li><strong>工作单元 任务分解</strong> ：Fiber最重要的功能就是作为工作单元，保存原生节点或者组件节点对应信息（包括优先级），这些节点通过指针的形似形成Fiber树</li><li><strong>增量渲染</strong>：通过jsx对象和current Fiber的对比，生成最小的差异补丁，应用到真实节点上</li><li><strong>根据优先级暂停、继续、排列优先级</strong>：Fiber节点上保存了优先级，能通过不同节点优先级的对比，达到任务的暂停、继续、排列优先级等能力，也为上层实现批量更新、Suspense提供了基础</li><li><strong>保存状态：</strong>因为Fiber能保存状态和更新的信息，所以就能实现函数组件的状态更新，也就是hooks</li><li><a href="https://songhaoyong.blogspot.com/2023/07/react.html">https://songhaoyong.blogspot.com/2023/07/react.html</a></li></ul><h2 id="2-render阶段"><a href="#2-render阶段" class="headerlink" title="2. render阶段"></a>2. render阶段</h2><p>render：Reconciler工作的阶段被称为render阶段。因为在该阶段会调用组件的render方法</p><p>render阶段的主要工作是构建Fiber树和生成effectList</p><p>开始工作前会先找到div#root对应的<code>rootFiber，称为</code>hostRootFiber<code>，然后开始生成</code>wip Fiber树<code>。 这个过程分为两个部分：beginWork</code>和completeWork。 这是一个深度优先遍历的过程。</p><p><strong>beginwork</strong>:主要的工作是创建或复用子fiber节点（同时涉及到diff算法，为结点打上effectTags）</p><p>从根节点rootFiber开始，遍历到叶子节点，每次遍历到的节点都会执行beginWork，并且传入当前Fiber节点，然后创建或复用它的子Fiber节点，并赋值给workInProgress.child。</p><p><strong>completework</strong>:主要工作是处理fiber的props、创建dom、创建effectList </p><p>1、(处理props将变化的部分賦值给workInProgerss.updateQueue)</p><p>2、mount时 调用createInstance创建dom，将后代dom节点插入刚创建的dom中</p><p>3、将effectTag的节点，加入到effectList中</p><p>当遍历到子节点后，会执行completeWork方法，执行完成之后会判断此节点的兄弟节点存不存在，如果存在就会为兄弟节点执行completeWork，当全部兄弟节点执行完之后，会向上回到父节点执行completeWork，直到rootFiber。</p><p>shouldYiled 方法就是判断待处理的任务队列有没有优先级更高的任务，有的话就先处理那边的 fiber，这边的先暂停一下。</p><h2 id="3-commit阶段"><a href="#3-commit阶段" class="headerlink" title="3. commit阶段"></a>3. commit阶段</h2><p>commit：Renderer工作的阶段被称为commit阶段。commit阶段会把render阶段提交的信息渲染在页面上</p><p>遍历render阶段生成的effectList，effectList上的Fiber节点保存着对应的props变化。之后会遍历effectList进行对应的dom操作和生命周期、hooks回调或销毁函数。</p><p><strong>commit阶段</strong>的主要工作（即Renderer的工作流程）分为三部分：</p><ul><li>before mutation阶段（执行DOM操作前）</li></ul><p>​这个阶段 DOM 节点还没有被渲染到界面上去，过程中会触发 <code>getSnapshotBeforeUpdate</code>，也会处理 <code>useEffect</code> 钩子相关的调度逻辑。</p><ul><li>mutation阶段（执行DOM操作）</li></ul><p>​这个阶段负责 DOM 节点的渲染。在渲染过程中，会遍历 effectList，根据effectTag的不同，执行不同的 DOM 操作。</p><ul><li><p>layout阶段（执行DOM操作后）</p><p>这个阶段处理 DOM 渲染完毕之后的收尾逻辑。比如调用 <code>componentDidMount/componentDidUpdate</code>，调用 <code>useLayoutEffect</code> 钩子函数的回调等。除了这些之外，它还会把 fiberRoot 的 current 指针指向 workInProgress Fiber 树。</p></li></ul><h2 id="4-render函数"><a href="#4-render函数" class="headerlink" title="4. render函数"></a>4. render函数</h2><p><strong>legacy模式</strong></p><p>render调用legacyRenderSubtreeIntoContainer，作用是</p><p>1、创建FiberRootNode和rootFiber节点, （调用createRootImpl，其会调用到createFiberRoot创建fiberRootNode,然后调用createHostRootFiber创建rootFiber）</p><p>2、调用updateContainer创建创建Update对象挂载到updateQueue的环形链表上，（然后执行scheduleUpdateOnFiber调用performSyncWorkOnRoot进入render阶段和commit阶段）</p><p><strong>concurrent模式：</strong></p><p>调用ReactDOMRoot.prototype.render执行updateContainer，调用updateContainer创建创建Update对象挂载到updateQueue的环形链表上，（然后scheduleUpdateOnFiber异步调度performConcurrentWorkOnRoot进入render阶段和commit阶段）</p><h2 id="5-fiber"><a href="#5-fiber" class="headerlink" title="5. fiber"></a>5. fiber</h2><p>Fiber是一个js对象，能承载节点信息、优先级、updateQueue，同时它还是一个工作单元。</p><ul><li><strong>工作单元 任务分解</strong> ：Fiber最重要的功能就是作为工作单元，保存原生节点或者组件节点对应信息（包括优先级），这些节点通过指针的形似形成Fiber树</li><li><strong>增量渲染</strong>：通过jsx对象和current Fiber的对比，生成最小的差异补丁，应用到真实节点上。（<code>fiber</code>将<code>react</code>中的渲染任务拆分到每一帧）</li><li><strong>根据优先级暂停、继续、排列优先级</strong>：Fiber节点上保存了优先级，能通过不同节点优先级的对比，达到任务的暂停、继续、排列优先级等能力，也为上层实现批量更新、Suspense提供了基础</li><li><strong>保存状态：</strong>因为Fiber能保存状态和更新的信息，所以就能实现函数组件的状态更新，也就是hooks</li></ul><h2 id="6-hooks的实现原理"><a href="#6-hooks的实现原理" class="headerlink" title="6. hooks的实现原理"></a>6. hooks的实现原理</h2><p><strong>在函数式组件中，hooks 的实现就是基于 fiber 的，多个hook会形成hook链表，保存在Fiber的memoizedState的上</strong>。hook不能写在条件判断中正因为hook会按顺序存储在链表中，如果hook写在条件判断中，就没法保持链表的顺序，会造成乱序。</p><p>hook调用入口</p><p>在hook源码中hook存在于Dispatcher中，Dispatcher就是一个对象，不同hook 调用的函数不一样，全局变量ReactCurrentDispatcher.current会根据是mount还是update赋值为HooksDispatcherOnMount或HooksDispatcherOnUpdate。</p><p>usestate的工作原理</p><p>useState分为onMount和upDate两种情况，通过全局变量ReactCurrentDispatcher.current来判断。</p><p>onMount时，hook.memoizedState记录初始的值</p><p>update更新时：</p><p>其中hooks的<code>memoizedState</code>是用来记录这个<code>useState</code>应该返回的结果的，而<code>next</code>指向的是下一次<code>useState</code>对应的&#96;Hook对象。</p><p>memoizedState装着state，而dispatchAction 就是setState</p><p>dispatchAction 创建新的update对象，将这些更新对象放到hook.queue.pending的环形链表中，最后重新渲染app</p><p>hooks的数据结构</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="attr">hook</span>: <span class="title class_">Hook</span> = &#123;</span><br><span class="line">  <span class="attr">memoizedState</span>: <span class="literal">null</span>,<span class="comment">//对于不同hook，有不同的值</span></span><br><span class="line">  <span class="attr">baseState</span>: <span class="literal">null</span>,<span class="comment">//初始state</span></span><br><span class="line">  <span class="attr">baseQueue</span>: <span class="literal">null</span>,<span class="comment">//初始queue队列</span></span><br><span class="line">  <span class="attr">queue</span>: <span class="literal">null</span> <span class="comment">// &#123; pending:这是一个链表储存着update&#125;,//需要更新的update</span></span><br><span class="line">  <span class="attr">next</span>: <span class="literal">null</span>,<span class="comment">//下一个hook</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="7、react的状态更新流程"><a href="#7、react的状态更新流程" class="headerlink" title="7、react的状态更新流程"></a>7、react的状态更新流程</h2><img src="img/image-20230511104437245.png" alt="image-20230511104437245" style="zoom:150%;" /><p>触发更新后，会在函数createUpdate中创建update更新，并将其加入到updateQueue中，会从触发更新的节点开始向上遍历到rootFiber，遍历的过程会处理节点的优先级。然后根据优先级调度render阶段的入口函数。最后进行render阶段和commit阶段。</p>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
