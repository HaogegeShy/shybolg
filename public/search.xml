<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>第 四 篇文章 计算机网络</title>
      <link href="/2022/09/01/4/"/>
      <url>/2022/09/01/4/</url>
      
        <content type="html"><![CDATA[<h1 id="计算机网络"><a href="#计算机网络" class="headerlink" title="计算机网络"></a>计算机网络</h1><h2 id="1-http2与http1之间的区别？"><a href="#1-http2与http1之间的区别？" class="headerlink" title="1. http2与http1之间的区别？"></a>1. http2与http1之间的区别？</h2><p>1.<strong>新的二进制格式</strong>：HTTP2采用二进制格式而HTTP1使用文本格式。</p><p>2.<strong>多路复用</strong>：HTTP2是完全多路复用的，而非有序并阻塞的，只需一个连接即可实现并行。HTTP1一个连接只能发送一个请求。</p><p>3.<strong>首部压缩</strong>：HTTP1.x的header带有大量信息，而且每次都要重复发送，HTTP2.0使用encoder来减少需要传输的header大小，通讯双方各自cache一份header fields表，既避免了重复header的传输，又减小了需要传输的大小。</p><p>4.<strong>服务器推送</strong>：HTTP2在客端请求资源的时候，会把相关的资源一起发送给客户端，而不需要客户端再次发起请求获取资源。</p><p>原文链接：<a href="https://blog.csdn.net/weixin_40300870/article/details/127305593">https://blog.csdn.net/weixin_40300870/article/details/127305593</a></p><h2 id="2-websocket"><a href="#2-websocket" class="headerlink" title="2. websocket"></a>2. websocket</h2><p>WebSocket是HTML5下一种基于tcp的能够全双工通信的持久化协议。</p><p>同：都是基于tcp协议的，都是可靠的传输协议。都是应用层的。</p><p>http协议是单向的、无状态、无连接的通信协议，通信只能客户端请求，服务器回答，一次tcp连接只能发起一次请求。而Websocket允许客户端和服务器全双工通讯，只需一次连接，长久通信。</p><h2 id="3-强制缓存与协商缓存"><a href="#3-强制缓存与协商缓存" class="headerlink" title="3. 强制缓存与协商缓存"></a>3. 强制缓存与协商缓存</h2><p><a href="https://www.jianshu.com/p/fb59c770160c/">https://www.jianshu.com/p/fb59c770160c/</a></p><p>缓存的原理：在首次请求后保存一份请求资源的响应副本，当用户再次发起相同请求后，如果判断缓存命中则拦截请求，将之前存储的响应副本返回给用户，从而避免重新向服务器发起资源请求。</p><p>强制缓存： 通过cache-control和expires判断资源是否过期，没过期直接使用缓存资源，返回200，过期重新发起请求，与强制缓存相关的两个字段：<strong>expires、cache-control</strong><br>协商缓存：通过get去<strong>请求服务器验证</strong>资源是否更新，如果没更新返回304 继续使用本地缓存，过期就返回200。主要通过<strong>last-modified</strong>和<strong>etag</strong>值判断</p><h2 id="4-在浏览器输入url后会发生的过程："><a href="#4-在浏览器输入url后会发生的过程：" class="headerlink" title="4. 在浏览器输入url后会发生的过程："></a>4. 在浏览器输入url后会发生的过程：</h2><p>1.DNS对域名进行解析；<br>2.建立TCP连接（<a href="https://so.csdn.net/so/search?q=%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B&spm=1001.2101.3001.7020">三次握手</a>）；<br>3.发送HTTP请求；<br>4.服务器处理请求；<br>5.返回响应结果；<br>6.关闭TCP连接（四次挥手）；<br>7.浏览器解析HTML；<br>8.浏览器布局渲染；</p><h2 id="5-http和https区别"><a href="#5-http和https区别" class="headerlink" title="5. http和https区别"></a>5. http和https区别</h2><p>1、HTTP协议以明文方式发送内容，不提供任何方式的数据加密。HTTP协议不适合传输一些敏感信息，比如：信用卡号、密码等支付信息。https则是具有安全性的ssl加密传输协议。2、http和https使用的是完全不同的连接方式，用的端口也不一样，前者是80，后者是443。3、并且https协议需要到ca申请证书。HTTPS协议是由SSL+HTTP协议构建的可进行加密传输、身份认证的网络协议，要比http协议安全。</p><ol start="6"><li>网络攻击XSS和CSRF</li></ol><p>xss，即 Cross Site Script，中文翻译是跨站脚本攻击。XSS 攻击是指攻击者在网站上注入恶意的客户端代码，通过恶意脚本对客户端网页进行篡改，从而在用户浏览网页时，对用户浏览器进行控制或者获取用户隐私数据的一种攻击方式。攻击者对客户端网页注入的恶意脚本一般包括 JavaScript，有时也会包含 HTML 和 Flash。</p><p>应对：1、<strong>HttpOnly 防止劫取 Cookie</strong>， 2、<strong>输入检查</strong>，一般是检查用户输入的数据中是否包含 &lt;，&gt; 等特殊字符，如果存在，则对特殊字符进行过滤或编码，3、<strong>输出检查</strong></p><p>CSRF，即 Cross Site Request Forgery，中译是跨站请求伪造，是一种劫持受信任用户向服务器发送非预期请求的攻击方式。通常情况下，CSRF 攻击是攻击者借助受害者的 Cookie 骗取服务器的信任，可以在受害者毫不知情的情况下以受害者名义伪造请求发送给受攻击服务器，从而在并未授权的情况下执行在权限保护之下的操作。</p><p>应对：1添加token认证，2验证码，CSRF 攻击往往是在用户不知情的情况下构造了网络请求。而验证码会强制用户必须与应用进行交互，才能完成最终请求。</p><h2 id="6-从输入url到页面完成加载发生了什么"><a href="#6-从输入url到页面完成加载发生了什么" class="headerlink" title="6. 从输入url到页面完成加载发生了什么"></a>6. 从输入url到页面完成加载发生了什么</h2><p><a href="https://blog.csdn.net/china_coding/article/details/127188830">https://blog.csdn.net/china_coding/article/details/127188830</a></p><ul><li><p>DNS解析：将域名解析成IP地址</p></li><li><p>TCP连接：TCP三次握手</p></li><li><p>发送HTTP请求</p></li><li><p>服务器处理请求并返回HTTP报文</p></li><li><p>浏览器解析渲染页面</p></li></ul><h2 id="7-CDN"><a href="#7-CDN" class="headerlink" title="7. CDN"></a>7. CDN</h2><p>Content Delivery Network，内容分发⽹络，CDN是指⼀种通过互联⽹互相连接的⽹络系统，利⽤最靠近⽤户的服务器，更快、更可靠地将资源发送给⽤户。</p><p>CDN的作⽤ ：</p><p>CDN⼀般会⽤来托管Web资源（包括⽂本、图⽚和脚本等），可供下载的资源（媒体⽂件、软件、⽂档 等），应⽤程序（⻔户⽹站等）。使⽤CDN来加速这些资源的访问。</p><p>（1）在性能⽅⾯，引⼊CDN的作⽤在于： ⽤户收到的内容来⾃最近的数据中⼼，延迟更低，内容加载更快，部分资源请求分配给了CDN，减少了服务器的负载。</p><p>（2）在安全⽅⾯，CDN有助于防御DDoS、MITM等⽹络攻击： 针对DDoS：通过监控分析异常流量，限制其请求频率 针对MITM：从源服务器到 CDN 节点到 ISP（Internet Service Provider），全链路 HTTPS 通信 除此之外，CDN作为⼀种基础的云服务，同样具有资源托管、按需扩展（能够应对流量⾼峰）等⽅⾯的 优势。</p><h2 id="8-浏览器状态码"><a href="#8-浏览器状态码" class="headerlink" title="8. 浏览器状态码"></a>8. 浏览器状态码</h2><p><img src="/img/articles/image-20230401170135854.png"></p><p><strong>1xx</strong></p><p>100：（继续） 请求者应当继续提出请求。 服务器返回此代码表示已收到请求的第一部分，正在等待其余部分。</p><p>101：（切换协议） 请求者已要求服务器切换协议，服务器已确认并准备切换。</p><p>102：由WebDAV（RFC 2518）扩展的状态码，代表处理将被继续执行。</p><p><strong>2XX</strong></p><p>200：（成功） 服务器已成功处理了请求。 通常，这表示服务器提供了请求的网页。</p><p>201：（已创建） 请求成功并且服务器创建了新的资源。</p><p>202：（已接受） 服务器已接受请求，但尚未处理。</p><p>203：（非授权信息） 服务器已成功处理了请求，但返回的信息可能来自另一来源。</p><p>204：（无内容） 服务器成功处理了请求，但没有返回任何内容。</p><p>205：（重置内容） 服务器成功处理了请求，但没有返回任何内容。</p><p>206：（部分内容） 服务器成功处理了部分 GET 请求。</p><p>208：（已经报告）一个DAV的绑定成员被前一个请求枚举，并且没有被再一次包括。</p><p>226：（IM Used）服务器已经满足了请求所要的资源，并且响应是一个或者多个实例操作应用于当前实例的结果。</p><p><strong>3XX</strong></p><p>300：（多种选择） 针对请求，服务器可执行多种操作。 服务器可根据请求者 (user agent) 选择一项操作，或提供操作列表供请求者选择。</p><p>301：（<strong>永久移动</strong>） 请求的网页已永久移动到新位置。 服务器返回此响应（对 GET 或 HEAD 请求的响应）时，会自动将请求者转到新位置。</p><p>302：（<strong>临时移动</strong>） 服务器目前从不同位置的网页响应请求，但请求者应继续使用原有位置来进行以后的请求。</p><p>303：（<strong>查看其他位置</strong>） 请求者应当对不同的位置使用单独的 GET 请求来检索响应时，服务器返回此代码。</p><p>304：（未修改） 自从上次请求后，请求的网页未修改过。 服务器返回此响应时，不会返回网页内容。</p><p>305：（使用代理） 请求者只能使用代理访问请求的网页。 如果服务器返回此响应，还表示请求者应使用代理。</p><p>307：（<strong>临时重定向</strong>） 服务器目前从不同位置的网页响应请求，但请求者应继续使用原有位置来进行以后的请求。</p><p>308：（永久转移）这个请求和以后的请求都应该被另一个URI地址重新发送。307、308和302、301有相同的表现，但是不允许HTTP方法改变。例如，请求表单到一个永久转移的资源将会继续顺利地执行。</p><p><strong>4XX</strong></p><p>400:（错误请求) 服务器不理解请求的语法。</p><p>401：(未授权) 请求要求身份验证。 对于需要登录的网页，服务器可能返回此响应。</p><p>402：该状态码是为了将来可能的需求而预留的。</p><p>403：（禁止) 服务器拒绝请求。</p><p>404：（未找到) 服务器找不到请求的网页。</p><p><strong>5XX</strong></p><p>500：（服务器内部错误） 服务器遇到错误，无法完成请求。</p><p>501：（尚未实施） 服务器不具备完成请求的功能。 例如，服务器无法识别请求方法时可能会返回此代码。</p><p>502：（错误网关） 服务器作为网关或代理，从上游服务器收到无效响应。</p><p>503：（服务不可用） 服务器目前无法使用（由于超载或停机维护）。 通常，这只是暂时状态。</p><p>504：（网关超时） 服务器作为网关或代理，但是没有及时从上游服务器收到请求。</p><p>505：（HTTP 版本不受支持） 服务器不支持请求中所用的 HTTP 协议版本。</p><p>200表示服务器<strong>响应成功</strong></p><p>301代表的是<strong>永久性的重定向</strong></p><p>302代表<strong>临时跳转</strong>，URL地址A可以向URL地址B上跳转</p><p>304可以告诉客户端<strong>请求资源成功</strong></p><p>403代表请求的服务器资源<strong>权限不够</strong></p><p>404代表服务器上<strong>没有该资源</strong></p><p>500代表<strong>程序错误</strong></p><h2 id="9-get和post的区别"><a href="#9-get和post的区别" class="headerlink" title="9. get和post的区别"></a>9. get和post的区别</h2><p><strong>本质区别：</strong>GET是从服务器上<strong>获得数据</strong>；POST是向服务器<strong>传递数据</strong></p><p><strong>数据传输上：</strong></p><p>get，通过拼接url进行传递参数；</p><p>post，通过body体传输参数</p><p><strong>缓存性：</strong></p><p>get请求是可以缓存的</p><p>post请求不可以缓存</p><p><strong>后退页面的反应：</strong></p><p>get请求页面后退时，不产生影响</p><p>post请求页面后退时，会重新提交请求</p><p><strong>大小限制</strong></p><p>GET请求在URL中传送的参数是有长度限制的，而POST没有</p><h2 id="10-浏览器渲染流程"><a href="#10-浏览器渲染流程" class="headerlink" title="10. 浏览器渲染流程"></a>10. 浏览器渲染流程</h2><p><img src="/img/articles/image-20230401204636208.png"></p><p>1、解析html文件，生成dom树，并行下载css&#x2F;js&#x2F;img文件</p><p>2、css下载完成后，生成cssom树</p><p>3、根据dom树和css树，生成render树</p><p>4、重排：计算各元素的位置和大小</p><p>5、重绘：将计算的结果渲染到页面上</p><p><img src="/img/articles/image-20230401203143141.png"></p><p>（js执行会阻塞DOM树的解析和渲染），所以可以加上defer和async</p><p>正常情况下，当浏览器在解析HTML源文件时如果遇到外部的script，那么解析过程会暂停，并发送请求来下载script文件，只有script完全下载并执行后才会继续执行DOM解析。</p><p>defer(延期、推迟)</p><p>让js脚本在文档解析完成后才执行，DOMContentLoaded之前执行</p><p><img src="/img/articles/image-20230401204044605.png"></p><p>ansyc(异步)</p><p>js脚本和浏览器的渲染是异步执行的</p><ul><li>css加载不会阻塞DOM树的解析</li><li>css加载会阻塞DOM树的渲染</li><li>css加载会阻塞后面js语句的执行 原因（由于js可能会操作之前的Dom节点和css样式，因此浏览器会维持html中css和js的顺序，因此，样式表会在后面的js执行前先加载执行完毕。所以css会阻塞后面js的执行。）</li></ul><p>css 加载会不会阻塞 js 的加载？（不会）</p><p>css 加载会不会阻塞 js 的执行？（会）</p><p>css 加载会不会阻塞 DOM 的解析？（不会）</p><p>css 加载会不会阻塞 DOM 的渲染？（会）</p><p>js 加载会不会阻塞 DOM 的解析？（会）</p><p>js 加载会不会阻塞 DOM 的渲染？（会）</p><p><strong>DOMContentLoaded 与onload区别</strong></p><p>1、 <code>onload</code> 页面的所有资源都加载完成才会触发，这些资源包括css、js、图片视频等。</p><p>2、当 <code>DOMContentLoaded</code> 事件触发时，仅当DOM加载完成，不包括样式表，图片，flash。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 计算机网络 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>第 三 篇文章 Git</title>
      <link href="/2022/08/10/3/"/>
      <url>/2022/08/10/3/</url>
      
        <content type="html"><![CDATA[<h1 id="Git"><a href="#Git" class="headerlink" title="Git"></a>Git</h1><p><strong>上传到github</strong>先git init, git add . ,git commit -m ‘ ‘, 再关联远程库</p><p>Git 中的三个<strong>区域</strong>：工作区、暂存区、Git 仓库。</p><p>工作区：处理工作的区域</p><p>暂存区：已完成的工作的临时存放区域，等待被提交</p><p>Git 仓库：最终的存放区域</p><p>Git 中的三种<strong>状态</strong>：已修改 modified 已暂存 staged 已提交 committed</p><p><strong>已修改</strong>：表示修改了文件，但还没将修改的结果放到暂存区。</p><p><strong>已暂存</strong>：表示对已修改文件的当前 版本做了标记，使之包含 在下次提交的列表中。</p><p><strong>已提交</strong>：表示文件已经安全地保存 在本地的 Git 仓库中。</p><p>注意：</p><p>⚫ 工作区的文件被修改了，但还没有放到暂存区，就是已修改状态。</p><p>⚫ 如果文件已修改并放入暂存区，就属于已暂存状态。</p><p>⚫ 如果 Git 仓库中保存着特定版本的文件，就属于已提交状态。</p><h2 id="Git的基本操作"><a href="#Git的基本操作" class="headerlink" title="Git的基本操作"></a>Git的基本操作</h2><ol><li><p>git init 命令会创建一个名为 .git 的隐藏目录，这个 .git 目录就是当前项目的 Git 仓库，里面包含了初始的必要文件，这些文件是 Git 仓库的必要组成部分。</p></li><li><p>git add 开始跟踪一个文件，git add . 一次性将所有的新增和修改过的文件加入暂存区</p></li><li><p>git status 命令查看文件处于什么状态</p></li><li><p>git commit 命令进行提交, 其中 -m 选项后面是本次的提交消息，用来对提交的内容做进一步的描述：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git commit -m <span class="string">&#x27;什么信息&#x27;</span></span><br></pre></td></tr></table></figure></li><li><p>跳过使用暂存区域</p></li></ol><p>Git 标准的工作流程是<strong>工作区 → 暂存区 → Git 仓库</strong>。Git 工作的流程简化为了<strong>工作区 → Git 仓库</strong>。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git commit -a -m <span class="string">&#x27;描述信息&#x27;</span></span><br></pre></td></tr></table></figure><ol start="6"><li><p>移除文件</p><p>从 Git 仓库中移除文件的方式有两种： </p><p>① 从 Git 仓库和工作区中同时移除对应的文件 </p><p>② 只从 Git 仓库中移除指定的文件，但保留工作区中对应的文件</p></li></ol><p><img src="/img/articles/image-20221025163441508.png"></p><h2 id="Git分支的概念"><a href="#Git分支的概念" class="headerlink" title="Git分支的概念"></a>Git分支的概念</h2><p>master 主分支</p><p>功能分支</p><ol><li><p>创建新分支       <strong>git branch 分支名称</strong>  </p><p>基于当前分支，创建一个新的分支，创建好分支后，当前位置还是在master分支上</p></li><li><p>切换分支     <strong>git checkout 分支名称</strong>     </p><p>可以切换到指定的分支上进行开发</p></li><li><p>分支的快速创建和切换  <strong>git checkout -b 分支名称</strong></p></li><li><p>合并分支   先切换到 master分支上，再运行 <strong>git merge 分支名称</strong> 命令，来合并功能分支</p><p>功能分支的代码开发测试完毕之后，可以使用命令，将完成后的代码合并到 master 主分支上</p></li><li><p>删除分支 <strong>git branch -d 分支名称</strong></p><p>当把功能分支的代码合并到 master 主分支上以后，就可以使用命令，删除对应的功能分支</p></li></ol><p>​6、git remote prune origin 清理本地仓库中与远程仓库中origin关联的已经不存在的分支引用</p><h2 id="远程分支操作"><a href="#远程分支操作" class="headerlink" title="远程分支操作"></a>远程分支操作</h2><ol><li>将本地分支推送到远程仓库</li></ol><p>​如果是第一次将本地分支推送到远程仓库，需要运行如下的命令：<br><img src="/img/articles/image-20221025164401144.png"></p><p>gitlab的操作，git pull origin 分支名</p><ol start="2"><li><p>查看远程仓库中所有的分支列表</p><p>通过如下的命令，可以查看远程仓库中，所有的分支列表的信息：</p></li></ol><p><img src="/img/articles/image-20221025164457908.png"></p><ol start="3"><li>跟踪分支</li></ol><p>​跟踪分支指的是：从远程仓库中，把远程分支下载到本地仓库中。需要运行的命令如下：<br><img src="/img/articles/image-20221025164539512.png"></p><ol start="4"><li><p>拉取远程分支的最新的代码</p><p>首先切换到本地分支</p><p>git pull origin 远程分支名</p><p>可以使用如下的命令，把远程分支最新的代码下载到本地对应的分支中：</p></li></ol><p><img src="/img/articles/image-20221025164618940.png"></p><ol start="5"><li><p>删除远程分支</p><p>可以使用如下的命令，删除远程仓库中指定的分支：</p></li></ol><p><img src="/img/articles/image-20221025164652215.png"></p><ol start="6"><li>合并分支冲突</li></ol><p>如果在两个不同的分支中，对同一个文件进行了不同的修改，Git 就没法干净的合并它们。 此时，我们需要打开 这些包含冲突的文件然后手动解决冲突。、</p><h2 id="git-clone"><a href="#git-clone" class="headerlink" title="git clone"></a>git clone</h2><p>git init</p><p>然后git clone +url</p><p>如果连接不上就</p><p><a href="https://blog.csdn.net/greatcoder/article/details/126138230">https://blog.csdn.net/greatcoder/article/details/126138230</a></p><p>git clone <a href="https://ghproxy.com/+github%E7%BD%91%E7%AB%99%E5%9C%B0%E5%9D%80">https://ghproxy.com/+github网站地址</a></p><p>就比如 git clone <a href="https://ghproxy.com/https://github.com/HaogegeShy/jingdong.git">https://ghproxy.com/https://github.com/HaogegeShy/jingdong.git</a></p><h2 id="git问题error-remote-origin-already-exists"><a href="#git问题error-remote-origin-already-exists" class="headerlink" title="git问题error: remote origin already exists"></a>git问题error: remote origin already exists</h2><p><a href="https://blog.csdn.net/qq_39208536/article/details/125231265">https://blog.csdn.net/qq_39208536/article/details/125231265</a></p><p>如果你clone下来一个别人的仓库，在此基础上完成你的代码，推送到自己的仓库可能遇到如下问题：<br>error: remote origin already exists.表示远程仓库已存在。<br>因此你要进行以下操作：<br>1、先输入git remote rm origin 删除关联的origin的远程库<br>2、关联自己的仓库 git remote add origin <a href="https://gitee.com/xxxxxx.git">https://gitee.com/xxxxxx.git</a><br>3、最后git push origin master，这样就推送到自己的仓库了。</p><h2 id="git代码提交到远程仓库时"><a href="#git代码提交到远程仓库时" class="headerlink" title="git代码提交到远程仓库时"></a>git代码提交到远程仓库时</h2><p>选用ssh的方式</p><h2 id="git-rebase和git-merge的区别"><a href="#git-rebase和git-merge的区别" class="headerlink" title="git rebase和git merge的区别"></a>git rebase和git merge的区别</h2><p>1、rebase变基，把当前的commit放到公共分支的最后面，merge把当前的commit和公共分支合并在一起，会产生一个合并的commit；</p><p>2、用merge命令解决完冲突后会产生一个commit，而用rebase命令解决完冲突后不会产生额外的commit。</p><p>merge中fast-forward 不会产生commit提交，–no-ff 会产生commit提交</p>]]></content>
      
      
      
        <tags>
            
            <tag> Git </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>第 二 篇文章 VUE底层原理</title>
      <link href="/2022/08/05/2/"/>
      <url>/2022/08/05/2/</url>
      
        <content type="html"><![CDATA[<h1 id="vue原理"><a href="#vue原理" class="headerlink" title="vue原理"></a>vue原理</h1><h2 id="1、mvvm"><a href="#1、mvvm" class="headerlink" title="1、mvvm"></a>1、mvvm</h2><ul><li>M：模型Model  —&gt;也就是data中的数据</li><li>V：视图View  —&gt;也就是dom</li><li>VM：视图模型ViewModel  —&gt;也就是Vue实例（vm）</li></ul><p><img src="/img/articles/image-20230521163900590.png"></p><h2 id="2、vue响应式原理"><a href="#2、vue响应式原理" class="headerlink" title="2、vue响应式原理"></a>2、vue响应式原理</h2><h3 id="核心api-object-defineProperty"><a href="#核心api-object-defineProperty" class="headerlink" title="核心api object.defineProperty"></a>核心api object.defineProperty</h3><p><img src="/img/articles/image-20230521164959631.png"></p><p>vue响应式也叫作数据双向绑定，大致原理阐述：</p><p> 首先我们需要通过Object.defineProperty()方法把数据(data)设置为getter和setter的访问形式，这样我们就可以在数据被修改时在setter方法设置监视修改页面信息，也就是说每当数据被修改，就会触发对应的set方法，然后我们可以在set方法中去调用操作dom的方法。</p><p> 此外，如果页面有input用v-model绑定数据，我们需要在这种绑定了data的input元素上添加监听，添加input事件监听，每当input事件被触发时，就修改对应的data</p><p>原文链接：<a href="https://blog.csdn.net/weixin_48181168/article/details/120158346">https://blog.csdn.net/weixin_48181168/article/details/120158346</a></p><p><img src="/img/articles/image-20230521192401756.png"></p><h3 id="vue3启用proxy"><a href="#vue3启用proxy" class="headerlink" title="vue3启用proxy"></a><strong>vue3启用proxy</strong></h3><p><a href="https://blog.csdn.net/pagnzong/article/details/120389514">https://blog.csdn.net/pagnzong/article/details/120389514</a></p><p>代码</p><p><img src="/img/articles/image-20230522155235201.png"></p><h3 id="proxy和object-defineProperty响应式的对比"><a href="#proxy和object-defineProperty响应式的对比" class="headerlink" title="proxy和object.defineProperty响应式的对比"></a>proxy和object.defineProperty响应式的对比</h3><p>vue2响应式的缺点：</p><ul><li>检测不到对象属性的添加和删除 （需要使用vue.set, vue.delete）</li><li>数组<code>API</code>方法无法监听到 (需要特殊处理)</li><li>深度监听需要递归到底，造成性能问题</li></ul><p>proxy解决的问题</p><ul><li>克服了vue2响应式的问题</li><li>缺点：没有兼容ie等其他浏览器，无法实现polyfill</li></ul><h2 id="3、虚拟dom和diff算法和react-diff的区别"><a href="#3、虚拟dom和diff算法和react-diff的区别" class="headerlink" title="3、虚拟dom和diff算法和react diff的区别"></a>3、虚拟dom和diff算法和react diff的区别</h2><p>用JS模拟DOM结构（vnode）<br>增量更新： 新旧vnode对比，得出最小的更新范围，最后更新DOM</p><p>数据驱动视图的模式下，有效控制DOM操作</p><p><img src="/img/articles/image-20230521193406678.png"></p><p>diff算法</p><ul><li><p>当数据发生改变时，订阅者<code>watcher</code>就会调用<code>patch</code>给真实的<code>DOM</code>打补丁</p></li><li><p>通过<code>isSameVnode</code>进行判断，相同则调用<code>patchVnode</code>方法</p></li><li><pre><code>patchVnode<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">  做了以下操作：</span><br><span class="line"></span><br><span class="line">  - 找到对应的真实`dom`，称为`el`</span><br><span class="line">  - 如果都有都有文本节点且不相等，将`el`文本节点设置为`Vnode`的文本节点</span><br><span class="line">  - 如果`oldVnode`有子节点而`VNode`没有，则删除`el`子节点</span><br><span class="line">  - 如果`oldVnode`没有子节点而`VNode`有，则将`VNode`的子节点真实化后添加到`el`</span><br><span class="line">  - 如果两者都有子节点，则执行`updateChildren`函数比较子节点</span><br><span class="line"></span><br><span class="line">- ```</span><br><span class="line">  updateChildren</span><br></pre></td></tr></table></figure>主要做了以下操作：- 设置新旧`VNode`的头尾指针- 新旧头尾指针进行比较，循环向中间靠拢，根据情况调用`patchVnode`进行`patch`重复流程、调用`createElem`创建一个新节点，从哈希表寻找 `key`一致的`VNode` 节点再分情况操作</code></pre></li></ul><p><strong>相同点：</strong><br>Vue和react的diff算法，都是不进行跨层级比较，只做同级比较</p><p><strong>不同点：</strong></p><ol><li>vue会在patch函数中给被操作的节点打补丁（patchflag），在diff的时候更清晰</li><li>vue对比节点，当节点元素类型相同，但是className不同时，认为是不同类型的元素，删除重新创建；而react则认为是同类型节点，进行修改操作</li><li>diff策略，vue的性能优于react</li></ol><h2 id="4、模板编译template"><a href="#4、模板编译template" class="headerlink" title="4、模板编译template"></a>4、模板编译template</h2><p>template-&gt;render-&gt;h-&gt;vdom-&gt;true dom</p><h2 id="5、vue组件的渲染和更新流程"><a href="#5、vue组件的渲染和更新流程" class="headerlink" title="5、vue组件的渲染和更新流程"></a>5、vue组件的渲染和更新流程</h2><p>初次渲染<br><img src="/img/articles/image-20230521212323764.png"></p><p>更新<br><img src="/img/articles/image-20230521212411230.png"></p><p>完整流程图<br><img src="/img/articles/image-20230521212545143.png"></p>]]></content>
      
      
      
        <tags>
            
            <tag> VUE </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>第 一 篇文章 React底层原理</title>
      <link href="/2022/07/30/1/"/>
      <url>/2022/07/30/1/</url>
      
        <content type="html"><![CDATA[<h1 id="React-底层原理"><a href="#React-底层原理" class="headerlink" title="React 底层原理"></a>React 底层原理</h1><p>至此我们介绍了react的理念，如何解决cpu和io的瓶颈，关键是实现异步可中断的更新</p><p>我们介绍了react源码架构（ui&#x3D;fn(state)），从scheduler开始调度（根据过期事件判断优先级，时间分片），经过render阶段的深度优先遍历形成effectList（中间会执行reconcile|diff），交给commit处理真实节点（中间穿插生命周期和部分hooks），而这些调度的过程都离不开Fiber的支撑，<strong>Fiber是工作单元，也是节点优先级、更新UpdateQueue、节点信息的载体</strong>，Fiber双缓存则提供了对比前后节点更新的基础。我们还介绍了jsx是React.createElement的语法糖。Lane模型则提供了更细粒度的优先级对比和计算，这一切都为concurrent mode提供了基础，在这之上变可以实现Suspense和batchedUpdate（16、17版本实现的逻辑不一样），context的valueStack和valueCursor在整个架构中运行机制，最后介绍了新版事件系统，包括事件生产、监听和触发</p><h2 id="1-react的架构"><a href="#1-react的架构" class="headerlink" title="1. react的架构"></a>1. react的架构</h2><p><a href="https://juejin.cn/post/7211072055780573221#heading-0">https://juejin.cn/post/7211072055780573221#heading-0</a></p><p><a href="https://juejin.cn/post/6926432527980691470">https://juejin.cn/post/6926432527980691470</a></p><p>作为架构来说，之前<code>React15</code>的<code>Reconciler</code>采用递归的方式执行，数据保存在递归调用栈中，所以被称为<code>stack Reconciler</code>。<code>React16</code>的<code>Reconciler</code>基于<code>Fiber节点</code>实现，被称为<code>Fiber Reconciler</code>。</p><p>新版React架构分为三大部分：</p><ul><li>Scheduler调度器：  排序优先级，让优先级高的任务先进行reconcile</li><li>Reconciler协调器：接受更新，创建虚拟dom树，找出哪些节点发生了改变，并打上不同的effectTag</li><li>Renderer渲染器：将Reconciler中打好标签的节点渲染到视图上</li></ul><p>Fiber这种数据结构后，能完成哪些事情呢，</p><ul><li><strong>工作单元 任务分解</strong> ：Fiber最重要的功能就是作为工作单元，保存原生节点或者组件节点对应信息（包括优先级），这些节点通过指针的形似形成Fiber树</li><li><strong>增量渲染</strong>：通过jsx对象和current Fiber的对比，生成最小的差异补丁，应用到真实节点上</li><li><strong>根据优先级暂停、继续、排列优先级</strong>：Fiber节点上保存了优先级，能通过不同节点优先级的对比，达到任务的暂停、继续、排列优先级等能力，也为上层实现批量更新、Suspense提供了基础</li><li><strong>保存状态：</strong>因为Fiber能保存状态和更新的信息，所以就能实现函数组件的状态更新，也就是hooks</li><li><a href="https://songhaoyong.blogspot.com/2023/07/react.html">https://songhaoyong.blogspot.com/2023/07/react.html</a></li></ul><h2 id="2-render阶段"><a href="#2-render阶段" class="headerlink" title="2. render阶段"></a>2. render阶段</h2><p>render：Reconciler工作的阶段被称为render阶段。因为在该阶段会调用组件的render方法</p><p>render阶段的主要工作是构建Fiber树和生成effectList</p><p>开始工作前会先找到div#root对应的<code>rootFiber，称为</code>hostRootFiber<code>，然后开始生成</code>wip Fiber树<code>。 这个过程分为两个部分：beginWork</code>和completeWork。 这是一个深度优先遍历的过程。</p><p><strong>beginwork</strong>:主要的工作是创建或复用子fiber节点（同时涉及到diff算法，为结点打上effectTags）</p><p>从根节点rootFiber开始，遍历到叶子节点，每次遍历到的节点都会执行beginWork，并且传入当前Fiber节点，然后创建或复用它的子Fiber节点，并赋值给workInProgress.child。</p><p><strong>completework</strong>:主要工作是处理fiber的props、创建dom、创建effectList </p><p>1、(处理props将变化的部分賦值给workInProgerss.updateQueue)</p><p>2、mount时 调用createInstance创建dom，将后代dom节点插入刚创建的dom中</p><p>3、将effectTag的节点，加入到effectList中</p><p>当遍历到子节点后，会执行completeWork方法，执行完成之后会判断此节点的兄弟节点存不存在，如果存在就会为兄弟节点执行completeWork，当全部兄弟节点执行完之后，会向上回到父节点执行completeWork，直到rootFiber。</p><p>shouldYiled 方法就是判断待处理的任务队列有没有优先级更高的任务，有的话就先处理那边的 fiber，这边的先暂停一下。</p><h2 id="3-commit阶段"><a href="#3-commit阶段" class="headerlink" title="3. commit阶段"></a>3. commit阶段</h2><p>commit：Renderer工作的阶段被称为commit阶段。commit阶段会把render阶段提交的信息渲染在页面上</p><p>遍历render阶段生成的effectList，effectList上的Fiber节点保存着对应的props变化。之后会遍历effectList进行对应的dom操作和生命周期、hooks回调或销毁函数。</p><p><strong>commit阶段</strong>的主要工作（即Renderer的工作流程）分为三部分：</p><ul><li>before mutation阶段（执行DOM操作前）</li></ul><p>​这个阶段 DOM 节点还没有被渲染到界面上去，过程中会触发 <code>getSnapshotBeforeUpdate</code>，也会处理 <code>useEffect</code> 钩子相关的调度逻辑。</p><ul><li>mutation阶段（执行DOM操作）</li></ul><p>​这个阶段负责 DOM 节点的渲染。在渲染过程中，会遍历 effectList，根据effectTag的不同，执行不同的 DOM 操作。</p><ul><li><p>layout阶段（执行DOM操作后）</p><p>这个阶段处理 DOM 渲染完毕之后的收尾逻辑。比如调用 <code>componentDidMount/componentDidUpdate</code>，调用 <code>useLayoutEffect</code> 钩子函数的回调等。除了这些之外，它还会把 fiberRoot 的 current 指针指向 workInProgress Fiber 树。</p></li></ul><h2 id="4-render函数"><a href="#4-render函数" class="headerlink" title="4. render函数"></a>4. render函数</h2><p><strong>legacy模式</strong></p><p>render调用legacyRenderSubtreeIntoContainer，作用是</p><p>1、创建FiberRootNode和rootFiber节点, （调用createRootImpl，其会调用到createFiberRoot创建fiberRootNode,然后调用createHostRootFiber创建rootFiber）</p><p>2、调用updateContainer创建创建Update对象挂载到updateQueue的环形链表上，（然后执行scheduleUpdateOnFiber调用performSyncWorkOnRoot进入render阶段和commit阶段）</p><p><strong>concurrent模式：</strong></p><p>调用ReactDOMRoot.prototype.render执行updateContainer，调用updateContainer创建创建Update对象挂载到updateQueue的环形链表上，（然后scheduleUpdateOnFiber异步调度performConcurrentWorkOnRoot进入render阶段和commit阶段）</p><h2 id="5-fiber"><a href="#5-fiber" class="headerlink" title="5. fiber"></a>5. fiber</h2><p>Fiber是一个js对象，能承载节点信息、优先级、updateQueue，同时它还是一个工作单元。</p><ul><li><strong>工作单元 任务分解</strong> ：Fiber最重要的功能就是作为工作单元，保存原生节点或者组件节点对应信息（包括优先级），这些节点通过指针的形似形成Fiber树</li><li><strong>增量渲染</strong>：通过jsx对象和current Fiber的对比，生成最小的差异补丁，应用到真实节点上。（<code>fiber</code>将<code>react</code>中的渲染任务拆分到每一帧）</li><li><strong>根据优先级暂停、继续、排列优先级</strong>：Fiber节点上保存了优先级，能通过不同节点优先级的对比，达到任务的暂停、继续、排列优先级等能力，也为上层实现批量更新、Suspense提供了基础</li><li><strong>保存状态：</strong>因为Fiber能保存状态和更新的信息，所以就能实现函数组件的状态更新，也就是hooks</li></ul><h2 id="6-hooks的实现原理"><a href="#6-hooks的实现原理" class="headerlink" title="6. hooks的实现原理"></a>6. hooks的实现原理</h2><p><strong>在函数式组件中，hooks 的实现就是基于 fiber 的，多个hook会形成hook链表，保存在Fiber的memoizedState的上</strong>。hook不能写在条件判断中正因为hook会按顺序存储在链表中，如果hook写在条件判断中，就没法保持链表的顺序，会造成乱序。</p><p>hook调用入口</p><p>在hook源码中hook存在于Dispatcher中，Dispatcher就是一个对象，不同hook 调用的函数不一样，全局变量ReactCurrentDispatcher.current会根据是mount还是update赋值为HooksDispatcherOnMount或HooksDispatcherOnUpdate。</p><p>usestate的工作原理</p><p>useState分为onMount和upDate两种情况，通过全局变量ReactCurrentDispatcher.current来判断。</p><p>onMount时，hook.memoizedState记录初始的值</p><p>update更新时：</p><p>其中hooks的<code>memoizedState</code>是用来记录这个<code>useState</code>应该返回的结果的，而<code>next</code>指向的是下一次<code>useState</code>对应的&#96;Hook对象。</p><p>memoizedState装着state，而dispatchAction 就是setState</p><p>dispatchAction 创建新的update对象，将这些更新对象放到hook.queue.pending的环形链表中，最后重新渲染app</p><p>hooks的数据结构</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="attr">hook</span>: <span class="title class_">Hook</span> = &#123;</span><br><span class="line">  <span class="attr">memoizedState</span>: <span class="literal">null</span>,<span class="comment">//对于不同hook，有不同的值</span></span><br><span class="line">  <span class="attr">baseState</span>: <span class="literal">null</span>,<span class="comment">//初始state</span></span><br><span class="line">  <span class="attr">baseQueue</span>: <span class="literal">null</span>,<span class="comment">//初始queue队列</span></span><br><span class="line">  <span class="attr">queue</span>: <span class="literal">null</span> <span class="comment">// &#123; pending:这是一个链表储存着update&#125;,//需要更新的update</span></span><br><span class="line">  <span class="attr">next</span>: <span class="literal">null</span>,<span class="comment">//下一个hook</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="7、react的状态更新流程"><a href="#7、react的状态更新流程" class="headerlink" title="7、react的状态更新流程"></a>7、react的状态更新流程</h2><img src="img/image-20230511104437245.png" alt="image-20230511104437245" style="zoom:150%;" /><p>触发更新后，会在函数createUpdate中创建update更新，并将其加入到updateQueue中，会从触发更新的节点开始向上遍历到rootFiber，遍历的过程会处理节点的优先级。然后根据优先级调度render阶段的入口函数。最后进行render阶段和commit阶段。</p>]]></content>
      
      
      
        <tags>
            
            <tag> React </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
